<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>vue-prev</title>
    <link rel="stylesheet" href="./common.css" >
    <script src="./vue.js"></script>
</head>
<body>
    <div id="app">
        <!-- <div class="block">
            <header>这里是标题</header>

            <section class="content">
                <div class="h">这里是内容快的标题</div>
                <div class="detail">这里是详细内容</div>
            </section>
        </div> -->


        <div class="block">
            <header>通过文本插值的方式显示数据</header>
            <section class="content">
                <div class="h">运用vue的{{  }}方式显示文本数据</div>
                <div class="detail">
                    <p>这里就是运行的结果:</p>
                    <b>{{ message }}</b>
                </div>
            </section>
        </div>

        <div class="block">
            <header>通过绑定节点特性的方式显示数据</header>
            <section class="content">
                <div class="h">运用vue的v-bind/:方式显示文本数据</div>
                <div class="detail">
                    <p>这里就是运行的结果(鼠标放在文本上会有提示的信息):</p>
                    <b :title="bindmessage">鼠标放在文本上会有提示的信息</b>
                </div>
            </section>
        </div>

        <div class="block">
            <header>条件指令控制元素的显示与否（只有为true的DOM才会显示再文档中与v-show不一样）</header>
            <section class="content">
                <div class="h">v-if控制显示与否</div>
                <div class="detail">
                    <p>
                        <button @click="toggle">点击修改seen的条件值</button>
                    </p>
                    <b v-if="seen">正向条件（显示）</b>
                    <b v-if="!seen">反响条件（隐藏）</b>
                </div>
            </section>
        </div>

        <div class="block">
            <header>还有很多的其他的指令这里我们先不做过多的介绍。后期我们会在api的学习中加强练习的</header>
            <section class="content">
                <div class="h">v-for循环输出数据</div>
                <div class="detail">
                    <p>这是循环输出数据的结果，大大简化了数据与dom之间的处理</p>
                    <p><button @click="additem">添加一个元素</button></p>
                    <ul>
                        <li v-for="data in datalist">
                            <p>地名：{{ data.name }} </p>
                            <p>拼音：{{ data.pinYin }}</p>
                            <p>简写：{{ data.py }}</p>
                            <hr/>
                        </li>
                    </ul>
                </div>
            </section>
        </div>

        <div class="block">
            <header>逻辑处理用户的输入</header>
            <section class="content">
                <div class="h">文本的反转</div>
                <div class="detail">
                    <p>请点击按钮</p>
                    <p><button @click="reverseMessage">开始处理</button></p>
                    <p>{{ message }}</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>处理用户的输入与运用--->(v-model)</header>
            <section class="content">
                <div class="h">双向绑定的使用</div>
                <div class="detail">
                    <p>请输入信息</p>
                    <p>
                        <input type="text" v-model="message">
                    </p>
                    <p>{{ message }}</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue的基础组件（这里是固定的文本组件）</header>
            <section class="content">
                <div class="h">基础组件的使用</div>
                <div class="detail">
                    <ul>
                        <component-name></component-name>
                    </ul>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue的props使用将数据从父作用域中传给子组件中</header>
            <section class="content">
                <div class="h">props的使用</div>
                <div class="detail">
                    <ul>
                        <data-from-parent
                            v-for="(data, index) in datalist"
                            :todo="data"
                            :key="index"></data-from-parent>
                    </ul>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue的数据和方法</header>
            <section class="content">
                <div class="h">Vue实例在创建的时候其中的数据data就应该初始化了，这样才会实时响应；如果在实例被创建后，向data中添加新的属性将会不能实时更新，所以如果你知道在晚些时候需要一些属性就应该提前初始化它</div>
                <div class="detail">
                    <p>以下就是一个案例，我们在实例创建之前添加属性a,在实例创建后添加属性b,看看a,b的变化情况</p>
                    <br/>
                    <p>{{ a }}<button @click="changeFun('a')">测试实时改变</button></p>
                    <br/>
                    <p>{{ b }}<button @click="changeFun('b')">测试实时改变</button></p>
                    <br/>
                    <p>
                        b在只针对它的事件进行调用的时候是不会实时更新（渲染update）的（我们只点击b的按钮的时候），但是其数据是在实时改变的，
                        只有在实例中的属性被重新渲染的时候才会跟随着一起更新；
                        结论：
                        所以只有在实例创建之前前的初始化属性改变才会调用实例相关的属性和方法。
                    </p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue防止修改其现有的属性freeze()</header>
            <section class="content">
                <div class="h">Vue实例创建之前的属性的改变会使DOM进行重新渲染，为了让其不进行渲染，我们可以对数据冻结，即对数据调用freeze()方法</div>
                <div class="detail">
                    <p>下面我们来通过按钮事件冻结我们的数据</p>
                    <br/>
                    <p></p><button @click="freezeData">开始冻结数据（这里的按钮的作用其实是无用的须在实例创建之前对数据对象进行冻结）</button></p>
                    <p>{{ message }}</p>
                    <p><input type="text" v-model="message"/></p>
                    <p>补充： 对象的冻结，需要在Vue实例创建之前，这样数据的改变就不会更新在视图上了（readonly)</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue中实例的属性及方法</header>
            <section class="content">
                <div class="h">Vue中实例的属性及方法我们用$开头，以便和我们自定义的数据属性进行区别</div>
                <div class="detail">
                    <p>下面我们来简单的使用一下$watch</p>
                    <p>在数据变化的时候我们希望执行一些操作，当然这些操作我们可以在声明周期的环节中进行，但是类似的操作都放在里面或许不是最好的解决方案</p>
                    <p><input type="text" v-model="message"/>{{ message }}</p>
                    <p>上面我们监听message数据的变化，当其改变的时候我们就会执行相关的操作</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue生命周期</header>
            <section class="content">
                <div class="h">在Vue实例创建之前要进行一系列的数据初始化，如： 设置数据监听、便宜模板、挂载实例到DOM、数据变化的时候实时更新DOM等操作，同时在这个过程中会运行一些生命周期钩子函数，给予用户在一定的场景下使用添加自己的代码的运用场景</div>
                <div class="detail">
                    <p>说明： 不要在选项属性或回掉上使用箭头函数，因为箭头函数是和上下文父级绑定在一起的，this并不会是你预期的Vue实例，所以在使用的时候经常会出现一些报错的情况</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue模板语法</header>
            <section class="content">
                <div class="h">文本插值我们上面已经使用了很多的示例，如message，这里我们介绍一次性插值操作v-once</div>
                <div class="detail">
                    <b v-once>{{ message }}</b>
                    <p><input type="text" v-model="message"></p>
                    <p>尝试输入数据修改input中的值看看它能不能实时改变，不出意外上面粗体的数据是不会改变的因为它只在创建实例的时候执行一次数据的插值操作</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue模板语法</header>
            <section class="content">
                <div class="h">html插值，我们可以将我们的html像文本插值的方式一样及进行插值操作，但是要使用v-html指令</div>
                <div class="detail">
                    <p>没有经过rawHtml处理：{{ htmlstr }}</p>
                    <p v-html="htmlstr"></p>
                    <br/>
                    <p>补充：很容易看到上面的两个操作的不同之处，但是在这里提示：网站上动态渲染的任何html操作可能十分的危险，很容易导致xxs的攻击，请对可信内容使用html的插值操作，绝不要对用户提供的内容使用插值</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue模板语法</header>
            <section class="content">
                <div class="h">特性，所谓的特性其实就是只使用特性的值或者方式，这里我们使用v-bind，在布尔特性的情况下，使按钮被点击</div>
                <div class="detail">
                    这里我们可以选择按钮的disabled的属性值
                    <select v-model="type">
                        <option v-for="buttonselect in buttonselects" :value="buttonselect">{{ buttonselect }}</option>
                    </select>
                    <button v-bind:disabled="type">此按钮不能被点击</button>
                    <br/>
                    <p>我们发现type为null、undefined、fasle不会被包含在渲染出来的button元素中（打开浏览器的DOM解构我们可以查看button上disabled属性存在与否）</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue模板语法</header>
            <section class="content">
                <div class="h">使用javascript表达式</div>
                <div class="detail">
                   <p>vue提供了完全的javascript表达式的支持,如以下案例</p>
                   <select v-model="type">
                        <option v-for="buttonselect in buttonselects" :value="buttonselect">{{ buttonselect }}</option>
                    </select>
                   <p>{{ count + 1 }}</p>
                   <p>{{ type ? 'type的值为true' : 'type的值为' + type }}</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>Vue模板语法</header>
            <section class="content">
                <div class="h">修饰符</div>
                <div class="detail">
                   <p>修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p>
                </div>
            </section>
        </div>

        
        <div class="block">
            <header>计算属性</header>
            <section class="content">
                <div class="h">先来看一个简单的计算属性的例子</div>
                <div class="detail">
                   <p>通过computed的方式</p>
                   <p>{{ getReverseMess }}</p>
                   <p>通过methods的方式</p>
                   <p>{{ mothodReverseMessage() }}</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>计算属性和方法之间的区别（重要！！）</header>
            <section class="content">
                <div class="h">对于计算属性来讲其更能很好处理实例依赖的属性的渲染工作，在依赖没有该改变的时候会直接返回上次处理的结果，儿而methods就不是了，每次的执行都要运行相关的逻辑代码</div>
                <div class="detail">
                    <p>以下是通过getReverseMess三次进行计算，但是实际上只的调用了一次，因为它在依赖没有改变的时候是以缓存的方式进行返回的并没有执行函数体</p>
                    <p>{{ getReverseMess }}</p>
                    <p>{{ getReverseMess }}</p>
                    <p>{{ getReverseMess }}</p>
                    <p>相反我们如果用methods的方式进行呢</p>
                    <p>{{ mothodReverseMessage() }}</p>
                    <p>{{ mothodReverseMessage() }}</p>
                    <p>{{ mothodReverseMessage() }}</p>
                    <br/>
                    <p>很明显，在console中我们看到了四次的methods中的mothodReverseMessage()执行（有一次的执行因为在上个案例中我们也使用了它），而computer中的getReverseMess只执行了一次，这对于依赖不经常变化的数据很是友好，大大的优化了处理不必要的逻辑</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>class的对象绑定方式（！！！）</header>
            <section class="content">
                <div class="h">通过在对象中传入属性，可以动态地切换多个class，</div>
                <div class="detail">
                    <div>
                        <p><span>是否显示：</span><input type="checkbox" v-model="isShow"/></p>
                        <p><span>是否显示边框：</span><input type="checkbox" v-model="isBorder"/></p>
                    </div>
                    <p class="hide" :class="{ show: isShow,'border': isBorder }">根据isShow的值进行显示这个文本</p>

                    <br/>
                    <p>上面的操作中我们将对象内联到模板中，当然我们也可以将对象放在实例中，例如</p>
                    <p class="hide" v-bind:class="outStyleObject">这里的class属性中的值我们将它放在了实例中，而我们只需要将对象绑定到class属性中即可（其实和上面的案例是一样的道理）</p>
                    
                    <br/>
                    <p>相比以上两种情况，这里我们介绍绑定一个返回对象的计算属性（！！！这个很是重要，这里我们可以运用vue实例对象添加相关的数据初始化并实时跟踪变化响应）</p>
                    <p class="hide" v-bind:class="initData">这里计算属性可以访问实例中的属性，并与其进行绑定，达到属性共享的作用</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>class的数组绑定方式</header>
            <section class="content">
                <div class="h">与对象的绑定方式有所不同，对象的绑定方式可能连带着类成立的条件，而数组的方式，主要体现类名上</div>
                <div class="detail">
                    <p>下面单独突出类型的形式</p>
                    <div class="hide" :class="[classBorder, classShow]">通过数组的方式绑定类名</div>

                    <br/>
                    <p>条件判断型：</p>
                    <div>
                        <p><span>是否显示：</span><input type="checkbox" v-model="isShow"/></p>
                        <p><span>是否显示边框：</span><input type="checkbox" v-model="isBorder"/></p>
                    </div>
                    <div class="hide" :class="[isShow ? classShow : '',isBorder ? classBorder : '']">
                        此例中我们通过三位运算符进行判断
                    </div>
                    <div class="hide" :class="[{'show': isShow},{'border': isBorder}]">
                        此例中我们通过数组中传对象的方式进行判断,不过这时在对象中的键值名称为类的名称（和类的绑定方式相像）
                    </div>
                    <br/>
                    <p><b>1.对象的方式以类名称为key值，value值为成立的条件</b></p>
                    <p><b>2.数组的方式，以data中的数据key值为类名代理，以value值为真是的类名</b></p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>class的数组绑定方式</header>
            <section class="content">
                <div class="h">组件中使用类的绑定和传统的html结构绑定类名（上文的案例有介绍）相同</div>
                <div class="detail">
                    <p>直接使用class(非绑定式)</p>
                    <class-component class="show border" classtype="非绑定式"></class-component>
                    <br/>
                    <p>条件判断型：</p>
                    <div>
                        <p><span>是否显示：</span><input type="checkbox" v-model="isShow"/></p>
                        <p><span>是否显示边框：</span><input type="checkbox" v-model="isBorder"/></p>
                    </div>
                    <p>条件型的类名绑定(绑定式)</p>
                    <class-component :class="initData" classtype="绑定式"></class-component>
                </div>
            </section>
        </div>

        <div class="block">
            <header>style的对象绑定方式（！！！写法很是重要：驼峰法、短线法、计算属性方法）</header>
            <section class="content">
                <div class="h">对象方式css的属性名称可以用驼峰命名法camelCase或者使用短横线的方式（但是要将属性名称用单引号引起来）</div>
                <div class="detail">
                   <p>驼峰法(请参考代码中的outCssOne)</p>
                   <div :style="outCssOne">It's so cool! 我是使用对象的驼峰法</div>
                </div>

                <div class="detail">
                   <p>短线法(请参考代码中的outCssTwo)</p>
                   <div :style="outCssTwo">It's so cool! 我是使用对象的驼峰法</div>
                </div>

                <div class="detail">
                    <p>计算属性返回法(请参考代码中的computed中的computedCss属性)</p>
                    <div :style="computedCss">It's so cool! 我是使用对象的驼峰法</div>
                </div>
            </section>
        </div>

        <div class="block">
            <header>style的数组绑定方式</header>
            <section class="content">
                <div class="h">数组的绑定方式</div>
                <div class="detail">
                    <div :style="[outCssOne]">我是使用数组的方式绑定的样式</div>
                </div>
            </section>
        </div>

        <div class="block">
            <header>当浏览器使用带有前缀的浏览器引擎类别css时，vue会自动识别并添加上</header>
            <section class="content">
                <div class="h">这方面vue帮我们做了很多的工作，但是在这方面的写法中我们还是需要注意的</div>
            </section>
        </div>

        <div class="block">
            <header>多重性</header>
            <section class="content">
                <div class="h">在对同一个css属性我们可以提供多个值，这样浏览器会根据不同的兼容性显示不同的值</div>
                <div class="detail">
                    <p>下面这个例子，我们以flex</p>
                    <div :style="{display: ['flex', '-webkit-box', '-ms-flexbox']}">
                        我是一个选择性综合征的对抗者,这里的属性值只会显示一个
                    </div>
                </div>
            </section>
        </div>

        <div class="block">
            <header>条件渲染</header>
            <section class="content">
                <div class="h">其实在前面我们已经有过相关的实例如v-if，而且还简述了他与v-show的区别</div>
                <div class="detail">
                    <p>这里我们将会简单的使用v-if、v-else</p>
                    <p>
                        <span>尝试勾去复选框看看：</span>
                        <input type="checkbox" v-model="ok">
                    </p>
                    <div v-if="ok">v-if的条件成立</div>
                    <div v-else>
                        v-if条件不成立
                    </div>
                </div>
            </section>
        </div>

        <div class="block">
            <header>使用条件渲染分组</header>
            <section class="content">
                <div class="h">当我们想切换多个元素的时候我们可以用分组（将条件写在template上，在渲染的时候他并不会出现）</div>
                <div class="detail">
                    <p>这里我们将使用渲染分组</p>
                    <p>
                        <span>显示标准答案：</span>
                        <input type="checkbox" v-model="ok">
                    </p>
                    <template v-if="ok">
                        <ul>
                            <li>锄禾日当午</li>
                            <li>汗滴禾下土</li>
                            <li>谁知盘中餐</li>
                            <li>粒粒皆辛苦</li>
                        </ul>
                    </template>
                    <div v-else>
                        答案已隐藏，你可以勾选复悬框来查看
                    </div>

                    <br/>
                    <p>
                        除了v-if和v-else、还存在v-else-if，这里说明，所有的这些条件控制必须相邻，v-else必须跟在v-if或者v-else-if的后面
                        这样他才能被正确的解析
                    </p>
                </div>
            </section>
        </div>


        <div class="block">
            <header>vue key管理可复用的元素</header>
            <section class="content">
                <div class="h">
                    vue为了高效地渲染元素，通常会复用已经存在的元素，而不会从头开始渲染
                    这样做还会保留用户的输入的内容
                </div>
                <div class="detail">
                    <p>下面的案例中我们将使用分组渲染的方式来体现vue的高速渲染（切换用户登录的方式）</p>

                    <template v-if="ok">
                        <label>username</label>
                        <input type="text" placeholder="请输入用户名称">
                    </template>
                    <template v-else>
                        <label>useremail</label>
                        <input type="text" placeholder="请输入用户邮箱">
                    </template>

                    <button @click="toggleInput">切换输入看看</button>

                    <br/>
                    <br/>
                    <p>
                        打开控制台，我们就可以看到DOM的改变只会改变label中的字段和input中的placeholder属性值；
                        但是有时候我们并不需要这种复用，想完全地独立他们，那么我们就要加上一个具有为唯一属性的key,
                        下面我们将举个栗子：
                    </p>
                    <template v-if="ok">
                        <label>username</label>
                        <input type="text" key="username-input" placeholder="请输入用户名称">
                    </template>
                    <template v-else>
                        <label>useremail</label>
                        <input type="text" key="useremail-input" placeholder="请输入用户邮箱">
                    </template>

                    <button @click="toggleInput">切换输入看看</button>

                    <p>打开控制台我们可以很明显地看到input的标签有所变动，并且input中的数据并没有缓存</p>
                </div>
            </section>
        </div>


        <div class="block">
            <header>v-if与v-show之间的区别</header>
            <section class="content">
                <div class="detail">
                    <p>
                    1、两者都算是条件渲染，但是v-if算是‘真正’的条件渲染；v-if根据条件对DOM进行渲染，条件成立才能渲染到界面上，而v-show是切换元素的display属性
                    当条件成立的时候display为block，反之为none。
                    </p>
                    <p>
                    2、v-if是<b>惰性</b>的，如果条件不成立的时候，它不会做任何的事情，只有当条件为真的时候才开始渲染条件块；而v-show不管,条件是否为真
                    它始终会渲染元素
                    </p>
                    <p>
                    3、通过上面的介绍，我们知道v-if有更高的切换开销，而v-show有更高的初始渲染开销；
                    如果条件切换的比较频繁，那么可以选择v-show，如果条件切换不是很频繁，我们可以使用v-if的方式比较好
                    </p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>v-if与v-for一起使用</header>
            <section class="content">
                <div class="detail">
                    <p>
                        v-if与v-for一起使用的时候，v-for具有更高的优先级
                    </p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>数组的列表渲染v-for</header>
            <section class="content">
                <div class="h">
                    v-for在上面的案例中我们也已经做过一定的介绍，v-for具有访问父级属性的权限，还支持一个可选的第二个参数为当前项的索引
                </div>
                <div class="detail">
                    <p>此案例中我们将引用父级的属性并为当前项使用索引</p>
                    <ul>
                        <li v-for="(data, index) in datalist">
                            {{ bindmessage }}--{{ data.name }}
                            <hr/>
                        </li>
                    </ul>
                    <br/>
                    <p>上面的迭代，我们用的是v-for in的方式，当然他也可以使用v-for of的方式</p>
                </div>
            </section>
        </div>

        <div class="block">
            <header>对象的列表渲染v-for</header>
            <section class="content">
                <div class="h">
                    对象的列表渲染可以接受三个参数
                </div>
                <div class="detail">
                    <p>此案例中我们使用对象进行列表渲染</p>
                    <ul>
                        <li v-for="(data, key, index) of vForObjects">
                            {{ index }}：当我们{{ key }}的时候，{{ data }}
                            <hr/>
                        </li>
                    </ul>
                    <br/>
                    <p>上面的迭代，我们用的是v-for of的方式，当然他也可以使用v-for in的方式</p>
                </div>
            </section>
        </div>



        <div class="block">
            <header>v-for的key（！！）</header>
            <section class="content">
                <div class="h">
                    v-for在更新已经渲染的列表元素，它会采用”就地服用“的，如果数据的顺序改变了，它并不会更新列表的顺序，这样减少了渲染
                </div>
                <div class="detail">
                    <p>
                        下面的案例中我们只改变数据的顺序来看看是否顺序会不会发生改变
                        <button @click="changeDataOrder">改变数据的顺序（我们这里只改变一次）</button>
                    </p>
                    <ul>
                        <li v-for="data in vForObjects">
                            当我们的时候，{{ data }}
                            <hr/>
                        </li>
                    </ul>
                    <br/>
                    <b><span class="red">(额哦～，这里没有成功)</span>，文档中给出的解释是只是使用于不依赖子组件状态或临时DOM状态（例如：表单输入值）的列表的渲染输出</b>
                    <p>为了让它重用或重新排序现有的元素，我们要跟踪每一个节点的身份，所以要提供一个key，即在循环元素上添加:key=“”</p>
                </div>
            </section>
        </div>
    
        <div class="block">
            <header>数组的更新检测(!!!!重要，否则在操作中数据可能不完整)</header>
            <section class="content">
                <div class="h">
                    v-for在更新已经渲染的列表元素，它会采用”就地服用“的，如果数据的顺序改变了，它并不会更新列表的顺序，这样减少了渲染
                </div>
                <div class="detail">
                    1.变异方法
                    <p>vue中包含一组观察数组的变异方法，所以他们将会触发视图的更新(因为这些方法会改变原始的数组数据)</p>
                    <u>
                        <li>push()</li>
                        <li>pop()</li>
                        <li>shift()</li>
                        <li>unshift</li>
                        <li>splice</li>
                        <li>sort()</li>
                        <li>reverse()</li>
                    </u>

                    <br/>
                    2.替换数组
                    <p>存在非变异的方法，例如filter(), concat() 和 slice()，他们总是返回一个新的数组，使用这些非变异的方法可以用新数组代替老数组</p>

                    <br/>
                    3.注意事项
                    <p>由于javascript的限制，我们不能直接通过索引直接设置一项</p>
                    <p>如： vm.items[indexOfItem] = newValue</p>
                    <p>我们也不能直接修改数组的长度</p>
                    <p>例如： vm.items.length = newLength</p>
                    <p>官网给出的说法是不能检测到（不知道是不能实时响应，还是不能实现添加的效果，根
                        据原生的情况个人猜测是可以添加上去的，但是数据不能实时更新到视图上而已，毕竟vue是实时响应），
                        但是其相关的值是否发生改变，下面的实例中我们一起来探讨</p>
                    <br/>
                    <div>
                        <p>面对第一个问题，我们有两种方式解决：</p>
                        <ul>
                            <li>
                                1.通过Vue的set()方法：Vue.set(vm.items, indexOfItems, newItem)
                            </li>
                            <li>
                                1.另一种就是通过原始的splice方式：vm.splice(indexOfItems, 1, newItem)
                            </li>
                        </ul>
                        <br/>
                        <p>下面我们将使用错误的方式和正确的方式进行演示一遍</p>
                        <div>
                            <section>
                                <p><button @click="errorAddItemToArrayByIndex">错误的方式:点击之后查看控制台的输出结果（添加新的一项）</button></p>
                                <ul>
                                    <li v-for="(item, index) of testArrays">
                                        {{ index }}----{{ item }}
                                    </li>
                                </ul>
                                <p>通过控制台我们清晰的看到，数组中是存在新添加的数据的，但是没有更新到视图上面去,可以将逻辑放到computed中，但是那样在页面加载的时候会自动调用一次</p>
                                <br/>
                                <p><button @click="errorChangeArrayLength">错误的方式:点击之后查看控制台的输出结果（改变数组的长度）</button></p>
                                <ul>
                                    <li v-for="(item, index) of testArrays">
                                        {{ index }}----{{ item }}
                                    </li>
                                </ul>
                            </section>
                            <br/>
                            <section>
                                <p><button @click="addItemToArrayByIndex">正确的方式:点击之后查看控制台的输出结果（添加新的一项）</button></p>
                                <ul>
                                    <li v-for="(item, index) of testArrays">
                                        {{ index }}----{{ item }}
                                    </li>
                                </ul>
                                <p>通过控制台我们清晰的看到，数组中是存在新添加的数据的，并且数据及时的渲染到了页面上</p>
                                <br/>
                                <p><button @click="changeArrayLength">错误的方式:点击之后查看控制台的输出结果（改变数组的长度）</button></p>
                                <ul>
                                    <li v-for="(item, index) of testArrays">
                                        {{ index }}----{{ item }}
                                    </li>
                                </ul>
                                <p>我们可以看到当我们改变了数组的长度后，空的数据就及时地反馈到了页面（当新数组的长度大于当前的并没有添加新的值，小于的时候减少了）</p>
                            </section>
                        </div>
                    </div>
                </div>
            </section>
        </div>

        <div class="block">
                <header>对象更改的检测注意事项（！！）</header>
                <section class="content">
                    <div class="h">
                        我们可能在逻辑处理的过程中需要改变数据原（对象的）的属性，如果是之前没有的属性值我们要实时检测并更新到视图上
                    </div>
                    <div class="detail">
                        <p>
                            其实在之前的实例中我们有相关沾边的案例，我们想用Vue自身的数据去初始化另一条它的数据，
                            但是在data中我们获取不到vue实例，所以就在computer中进行了计算初始化，使它刚开始调用的视乎就初始化；
                            然而并不是所有的对象数据都是在一开始的时候我们就初始化，那么我们怎么解决呢？
                        </p>
                        <ul>
                            <li>
                                <p>通过Vue中自带的全局Vue.set()方法或者使用实例的vm.$set()的方法对对象数据进行添加</p>
                                <div>
                                    <p>案例1(单个属性的变化)：</p>
                                    <p>
                                        <button @click="addNewObjectItemOne">新的对象属性</button>
                                        <div :style="outCssOne">
                                            点击上面的按钮，看看我有什么变化(这里第一次为新添加的，后面我们只是改变它的值而已)
                                        </div>
                                    </p>
                                    <br/>
                                    <p>案例1(单个属性的变化)：</p>
                                    <p>
                                        <button @click="addNewObjectItemOne">新的对象属性</button>
                                        <div :style="outCssOne">
                                            点击上面的按钮，看看我有什么变化(这里第一次为新添加的，后面我们只是改变它的值而已)
                                        </div>
                                    </p>
                                </div>
                            </li>
                        </ul>
                    </div>
                </section>
            </div>
        



        
    </div>
    <script src='./components/BasicComponent.js'></script>
    <script>
        var data = {
            message: `Hello vuejs! It\'s so cool`,//vue的开始文本插值
            bindmessage: `This is bind message `,//bind数据绑定的方式
            seen: true,//控制元素的显示与否，false为不显示也不出现再DOM上，二者只会出现一个,
            datalist: [
                { name: '北京', pinYin: 'beijing', py: 'bj', desc: 'BJS' },
                { name: '上海', pinYin: 'shanghai', py: 'sh', desc: 'BJS' },
                { name: '天津', pinYin: 'tianjin', py: 'tj', desc: 'BJS' }
            ],
            a: 'vue实例创建之前，创建并初始化的a',
            htmlstr:  `<b style="color: red">这里是html插值操作产生的</b>`,
            type: true,
            buttonselects: [true,false,null,undefined],
            count: 1,
            isShow: true,
            isBorder: true,
            outStyleObject: {
                show: true,
                'border': true
            },
            classShow: 'show',
            classBorder: 'border',
            outCssOne: {
                borderWidth: '2px',
                borderColor: 'red',
                borderStyle: 'solid'
            },
            outCssTwo: {//可以命名成borderStyle
                'border-width': '2px',
                'border-color': 'red',
                'border-style': 'solid'
            },
            ok: true,
            vForObjects: {
                born: '世界的每一个角落是不一样的，我们的降临是幸运的',
                young: '世界是美妙的，期待你发现的眼睛',
                old: '人生或许去不了世界的每一个角落，但是有你的地方每时每刻都是不一样的'
            },
            testArrays: ['孙悟空','猪八戒','沙和尚','白龙马'],
        };
        //对象的冻结，需要在Vue实例创建之前，这样数据的改变就不会更新在视图上了（readonly）,这里为了实时更新我们就注释掉这个功能点了
        //Object.freeze(data);
        var app = new Vue({
            el: '#app',
            data() {
                return data;
            },
            created: function () {
                //这里我们选择在实例创建完后，进行创建新的属性b
                this.b = 'vue实例创建完后，新创建的属性b';
            },
            updated: function() {
                console.log('a:'+this.b);
                console.log('b:'+this.b);
                //b在只针对它的事件尽行调用的时候是不会实时更新的（我们只点击b的按钮的时候），
                //只有在实例中的属性被重新渲染的时候才会跟随着一起更新
                //结论：
                //所以只有在实例创建之前前的初始化属性改变才会调用实例相关的属性和方法
            },
            computed: {
                getReverseMess: function() {
                    console.error('通过computed的方式进行执行');
                    return this.message.split('').reverse().join('');
                },
                initData: function() {
                    return { show: this.isShow,'border': this.isBorder};
                },
                computedCss: function() {
                    //return this.outCssOne;
                    return {
                        'border-width': '2px',
                        'border-color': 'red',
                        'border-style': 'solid'
                    };
                },
            },
            methods: {
                toggle: function() {
                    this.seen = !this.seen;
                },
                additem: function() {
                    //正常的数组添加数据
                    this.datalist.unshift({ name: '天津', pinYin: 'tianjin', py: 'tj', desc: 'BJS' });
                },
                reverseMessage: function() {
                    this.message = this.message.split(' ').reverse().join(' ');
                },
                mothodReverseMessage: function() {
                    console.error('通过methods的方式进行执行');
                    return this.message.split(' ').reverse().join(' ');
                },
                changeFun: function(string) {
                    if(string == 'a') {
                        this.a = Math.random()+"可以实时改变";
                    }else if(string == 'b'){
                        //这里当点击b的按钮是不会发生实时响应的，因为它是在实例创建完成后才生成的（created之后的属性），但是它
                        //的结果值是在不断的改变的，只有在其他的属性改变后他就会伴随着更新
                        this.b = Math.random()+"可以实时改变";
                    }
                },
                freezeData: function() {
                    Object.freeze(data);
                },
                toggleInput: function() {
                    this.ok = !this.ok;
                },
                changeDataOrder: function() {
                    this.vForObjects = {
                        young: '世界是美妙的，期待你发现的眼睛',
                        born: '世界的每一个角落是不一样的，我们的降临是幸运的',
                        old: '人生或许去不了世界的每一个角落，但是有你的地方每时每刻都是不一样的'
                    };
                },
                addItemToArrayByIndex: function() {
                    //针对用户自定义数组的下标
                    //方式1：
                    //Vue.set(this.testArrays, 4, '我是唐僧，请拒绝吃唐僧肉');

                    //方式二：
                    this.testArrays.splice(4, 1, '我是唐僧，请拒绝吃唐僧肉');
                    console.log(this.testArrays);
                },
                changeArrayLength: function() {
                    //方式1
                    //这里我们改变数组的长度
                    this.testArrays.splice(2);//这个好像有点问题，这里值如果下于当前数组的值是有效的，但是如果大于并没有添加值
                    console.log(this.testArrays.length);
                    console.log(this.testArrays);
                    this.testArrays.forEach(function(v, index) {
                        if(v==='undefined') {
                            console.log('undefined');
                        }else{
                            console.log(v);
                        }
                    })
                    //以上的写法并没有打到我们想要的（打印出undefined），但是我们可以清楚的看到有6个值的产生
                },
                errorAddItemToArrayByIndex: function() {
                    //这里我们在数组中通过下标的方式添加新的一项内容
                    this.testArrays[4] = '我是唐僧';
                    //这里我们可以看看数据是否添加上去了:
                    console.log(this.testArrays);
                    //在上面我们可以看看是否数据已经实时显示到页面
                },
                errorChangeArrayLength: function() {
                    //这里我们改变数组的长度
                    this.testArrays.length = 6;
                    console.log(this.testArrays);
                    this.testArrays.forEach(function(v, index) {
                        if(v==='undefined') {
                            console.log('undefined');
                        }else{
                            console.log(v);
                        }
                    })
                    //以上的写法并没有打到我们想要的（打印出undefined），但是我们可以清楚的看到有6个值的产生
                },
                addNewObjectItemOne: function() {
                    //这里我们通过全局的Vue.set()来实现
                    let red = this.randomFunc();
                    let green = this.randomFunc();
                    let blue = this.randomFunc();
                    let color = `rgb(${red},${green},${blue})`;
                    console.log(color);

                    //Vue.set(this.outCssOne,'color',color);

                    //这里我们通过实例的app.$set()方法来添加属性
                    app.$set(this.outCssOne,'color',color);

                    console.log(app.outCssOne);
                    console.log(this.outCssOne)
                },
                randomFunc: function() {
                    return Math.ceil(Math.random() * 255);
                } 

            }
        });

        //这里我们使用了实例的方法来监听数据的变化
        app.$watch('message', function() {
            console.warn('别慌，这里是正确的输出！,我在一直监听message的改变呢');
        });
        app.$watch('type', function() {
            console.log(this.type);
        });
    </script>
</body>
</html>